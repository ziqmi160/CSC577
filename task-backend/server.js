// server.js

// Import necessary modules
require('dotenv').config(); // Loads environment variables from .env file
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors'); // For enabling Cross-Origin Resource Sharing
// const natural = require('natural'); // No longer strictly needed if Python handles all semantic logic
const multer = require('multer');
const path = require('path');
const jwt = require('jsonwebtoken');
const User = require('./models/User');
const JWT_SECRET = process.env.JWT_SECRET || 'your_jwt_secret';
// Initialize Express app
const app = express();
const PORT = process.env.PORT || 5000; // Use port from .env or default to 5000
const MONGO_URI = process.env.MONGO_URI; // MongoDB URI from .env

// --- Python Semantic Service Configuration ---
const PYTHON_SERVICE_URL = process.env.PYTHON_SERVICE_URL || 'http://localhost:5001';
// In a real deployment, replace 'localhost' with the actual IP/hostname of your Python service.

// --- Middleware ---
// Enable CORS for all origins. In a production app, you'd specify allowed origins.
app.use(cors({
  origin: '*',
  methods: ['GET', 'POST', 'PATCH', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));
// Parse incoming JSON requests
app.use(express.json());

// --- Database Connection ---
mongoose.connect(MONGO_URI)
    .then(() => {
        console.log('MongoDB connected successfully!');
    })
    .catch(err => {
        console.error('MongoDB connection error:', err);
        process.exit(1); // Exit process if connection fails
    });

// --- Mongoose Schema and Model for Task ---
const taskSchema = new mongoose.Schema({
    title: {
        type: String,
        required: [true, 'Task title is required'],
        trim: true
    },
    description: {
        type: String,
        trim: true,
        default: ''
    },
    dueDate: {
        type: String, // Storing as String "YYYY-MM-DD" as per your frontend
        required: [true, 'Due date is required']
    },
    priority: {
        type: String,
        enum: ['High', 'Medium', 'Low'], // Ensure these match your frontend values
        default: 'Low'
    },
    completed: {
        type: Boolean,
        default: false
    },
    createdAt: {
        type: Date,
        default: Date.now // Automatically set creation date
    },
    embedding: { // NEW: Field to store the vector embedding from the Python service
        type: [Number], // Array of numbers
        required: false // Not required on initial creation, generated by Python service
    },
    label: {
        type: [String],
        default: []
    },
    attachment: {
        type: [String], // Store file URLs or file info as strings
        default: []
    },
    user: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
});

// IMPORTANT: Keep the text index as a fallback or for simple keyword searches
// while semantic search handles the 'q' parameter.
taskSchema.index({ title: 'text', description: 'text' }, { weights: { title: 2, description: 1 } });

// Create the Task model
const Task = mongoose.model('Task', taskSchema);

// --- Utility function to call Python service for embedding ---
async function sendForEmbedding(taskId, title, description) {
    try {
        const response = await fetch(`${PYTHON_SERVICE_URL}/embed_task`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                taskId: taskId.toString(), // Convert ObjectId to string for Python
                title: title,
                description: description
            }),
        });
        if (!response.ok) {
            const errorData = await response.json();
            console.error(`Error from Python embedding service: ${errorData.message}`);
        } else {
            console.log(`Task ${taskId} sent for embedding successfully.`);
        }
    } catch (error) {
        console.error(`Failed to connect to Python embedding service for task ${taskId}:`, error);
    }
}

// --- Auth Middleware ---
function authMiddleware(req, res, next) {
  const authHeader = req.headers['authorization'];
  if (!authHeader) return res.status(401).json({ message: 'No token provided' });
  const token = authHeader.split(' ')[1];
  if (!token) return res.status(401).json({ message: 'No token provided' });
  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) return res.status(403).json({ message: 'Invalid token' });
    req.user = user;
    next();
  });
}

// --- Auth Routes ---
app.post('/signup', async (req, res) => {
  try {
    const { username, email, password } = req.body;
    if (!username || !email || !password) {
      return res.status(400).json({ message: 'All fields are required' });
    }
    const existingUser = await User.findOne({ $or: [{ username }, { email }] });
    if (existingUser) {
      return res.status(409).json({ message: 'Username or email already exists' });
    }
    const user = new User({ username, email, password });
    await user.save();
    const signupPayload = { id: user._id, username: user.username, email: user.email };
    console.log('JWT payload (signup):', signupPayload);
    const signupToken = jwt.sign(signupPayload, JWT_SECRET, { expiresIn: '7d' });
    res.status(201).json({ token: signupToken, user: { id: user._id, username: user.username, email: user.email } });
  } catch (error) {
    console.error('Signup error:', error);
    res.status(500).json({ message: 'Server error', error: error.message });
  }
});

app.post('/login', async (req, res) => {
  try {
    console.log('Login body:', req.body);
    const { username, email, password } = req.body;
    if ((!username && !email) || !password) {
      return res.status(400).json({ message: 'All fields are required' });
    }
    // Find user by username or email
    const user = await User.findOne(username ? { username } : { email });
    if (!user) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    const loginPayload = { id: user._id, username: user.username, email: user.email };
    console.log('JWT payload (login):', loginPayload);
    const loginToken = jwt.sign(loginPayload, JWT_SECRET, { expiresIn: '7d' });
    res.status(200).json({ token: loginToken, user: { id: user._id, username: user.username, email: user.email } });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'Server error', error: error.message });
  }
});

// --- Protect all task routes below ---
app.use('/tasks', authMiddleware);

// --- API Routes ---

// // GET all tasks (with optional sorting and semantic search)
// app.get('/tasks', async (req, res) => {
//     try {
//         let query = {};
//         let sort = {};

//         // Semantic search using Python service
//         if (req.query.q) {
//             const originalQuery = req.query.q.trim();
//             console.log(`Semantic search requested for query: "${originalQuery}"`);

//             try {
//                 const pythonResponse = await fetch(`${PYTHON_SERVICE_URL}/search_semantic`, {
//                     method: 'POST',
//                     headers: { 'Content-Type': 'application/json' },
//                     body: JSON.stringify({ query: originalQuery })
//                 });

//                 if (!pythonResponse.ok) {
//                     const errorData = await pythonResponse.json();
//                     throw new Error(`Python semantic search service error: ${errorData.message}`);
//                 }

//                 const searchResults = await pythonResponse.json();
//                 const relevantTaskIds = searchResults.results.map(r => new mongoose.Types.ObjectId(r.taskId));
                
//                 console.log(`Semantic search returned ${relevantTaskIds.length} relevant task IDs.`);

//                 if (relevantTaskIds.length > 0) {
//                     // Fetch tasks from MongoDB using the IDs returned by Python service
//                     query._id = { $in: relevantTaskIds };
//                     // If you want to sort by semantic score, you'd need to re-order here
//                     // based on the 'score' property from searchResults.results
//                     // For now, let's keep the default sort or sort by createdAt
//                 } else {
//                     // If no results from semantic search, return empty array
//                     return res.status(200).json([]);
//                 }

//             } catch (pythonError) {
//                 console.error('Error calling Python semantic search service:', pythonError);
//                 // Fallback to simple text search or return empty if Python service fails
//                 // For this example, we'll just proceed with an empty result if Python fails
//                 return res.status(200).json([]); 
//             }
//         }

//         // Standard sorting for non-semantic queries or as a secondary sort
//         if (!req.query.q && req.query.sortBy) { 
//             const parts = req.query.sortBy.split(':');
//             if (parts.length === 2) {
//                 const [field, order] = parts;
//                 sort[field] = order === 'desc' ? -1 : 1;
//             }
//         } else if (!req.query.q || (req.query.q && Object.keys(query).length === 0)) {
//             // Default sort by creation date descending if no search, or if semantic search yielded no results
//             sort.createdAt = -1;
//         }

//         const tasks = await Task.find(query).sort(sort);
//         res.status(200).json(tasks);
//     } catch (error) {
//         console.error('Error fetching tasks:', error);
//         res.status(500).json({ message: 'Server error', error: error.message });
//     }
// });

// GET all tasks (with optional sorting, semantic search, and contains search)
app.get('/tasks', async (req, res) => {
    try {
        const originalQuery = req.query.q || req.query.contains; // Get the search term if any
        const useSemantic = !!req.query.q; // Check if semantic search was requested
        const useContains = !!req.query.contains; // Check if contains search was requested

        let semanticTaskIds = new Set();
        let containsTaskIds = new Set();

        // Perform Semantic Search if requested
        if (useSemantic && originalQuery) {
            console.log(`Semantic search requested for query: "${originalQuery}"`);
            try {
                const pythonResponse = await fetch(`${PYTHON_SERVICE_URL}/search_semantic`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query: originalQuery })
                });

                if (!pythonResponse.ok) {
                    const errorData = await pythonResponse.json();
                    throw new Error(`Python semantic search service error: ${errorData.message}`);
                }

                const searchResults = await pythonResponse.json();
                searchResults.results.forEach(r => semanticTaskIds.add(r.taskId));
                
                console.log(`Semantic search returned ${semanticTaskIds.size} relevant task IDs.`);

            } catch (pythonError) {
                console.error('Error calling Python semantic search service:', pythonError);
                // If semantic service fails, treat it as no semantic results
                semanticTaskIds.clear(); 
            }
        }

        // Perform "Contains" (Keyword) Search if requested
        if (useContains && originalQuery) {
            console.log(`"Contains" search requested for query: "${originalQuery}"`);
            const regexQuery = {
                $or: [
                    { title: { $regex: originalQuery, $options: 'i' } },
                    { description: { $regex: originalQuery, $options: 'i' } }
                ]
            };
            const containsTasks = await Task.find(regexQuery).select('_id'); // Only fetch IDs
            containsTasks.forEach(task => containsTaskIds.add(task._id.toString()));
            console.log(`"Contains" search returned ${containsTaskIds.size} relevant task IDs.`);
        }

        let combinedTaskIds = [];

        if (useSemantic && useContains) {
            // If both are checked, combine results (union of IDs)
            combinedTaskIds = Array.from(new Set([...semanticTaskIds, ...containsTaskIds]));
            console.log(`Combined semantic and contains search yielded ${combinedTaskIds.length} unique task IDs.`);
        } else if (useSemantic) {
            combinedTaskIds = Array.from(semanticTaskIds);
        } else if (useContains) {
            combinedTaskIds = Array.from(containsTaskIds);
        } else {
            // If no search type is checked, or no query, or no semantic/contains results,
            // we'll fetch all tasks or apply regular sorting.
        }

        let finalQuery = {};
        let sort = {};

        if (originalQuery && combinedTaskIds.length > 0) {
            // If a search query was made and results were found from either type
            finalQuery._id = { $in: combinedTaskIds.map(id => new mongoose.Types.ObjectId(id)) };
            // For combined results, we default to sorting by creation date for consistency.
            // If semantic results need to be prioritized, more complex sorting would be needed here
            // (e.g., merging based on semantic score vs. regex match relevance, which is advanced).
            sort.createdAt = -1; // Default sort for combined results
        } else if (originalQuery && combinedTaskIds.length === 0 && (useSemantic || useContains)) {
            // If a search was performed but no results were found, return empty.
            return res.status(200).json([]);
        } else {
            // Default behavior if no search query or no search types are selected
            if (req.query.sortBy) {
                const parts = req.query.sortBy.split(':');
                if (parts.length === 2) {
                    const [field, order] = parts;
                    sort[field] = order === 'desc' ? -1 : 1;
                }
            } else {
                sort.createdAt = -1; // Default sort for all tasks
            }
        }
        
        finalQuery.user = req.user.id; // Only fetch tasks for this user
        const tasks = await Task.find(finalQuery).sort(sort);
        res.status(200).json(tasks);
    } catch (error) {
        console.error('Error fetching tasks:', error);
        res.status(500).json({ message: 'Server error', error: error.message });
    }
});

// GET a single task by ID
app.get('/tasks/:id', async (req, res) => {
    try {
        const task = await Task.findById(req.params.id);
        if (!task || task.user.toString() !== req.user.id) {
            return res.status(404).json({ message: 'Task not found' });
        }
        res.status(200).json(task);
    } catch (error) {
        console.error('Error fetching single task:', error);
        res.status(500).json({ message: 'Server error', error: error.message });
    }
});

// POST a new task
app.post('/tasks', async (req, res) => {
    try {
        // Validate required fields
        if (!req.body.title || !req.body.dueDate) {
            return res.status(400).json({ message: 'Title and Due Date are required.' });
        }
        // Check for duplicate task title for this user
        const existingTask = await Task.findOne({ title: req.body.title, user: req.user.id });
        if (existingTask) {
            return res.status(409).json({ message: 'Task with this title already exists.' });
        }
        const newTask = new Task({
            title: req.body.title,
            description: req.body.description,
            dueDate: req.body.dueDate,
            priority: req.body.priority,
            completed: req.body.completed, // Allows setting initial completed status
            label: req.body.label || [],
            attachment: req.body.attachment || [],
            user: req.user.id // Associate with logged-in user
        });
        await newTask.save();
        // NEW: Send task to Python service for embedding after saving to DB
        await sendForEmbedding(newTask._id, newTask.title, newTask.description);
        res.status(201).json(newTask); // 201 Created
    } catch (error) {
        console.error('Error creating task:', error);
        res.status(500).json({ message: 'Server error', error: error.message });
    }
});

// PATCH (update) an existing task by ID
app.patch('/tasks/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const updates = req.body;
        const options = { new: true, runValidators: true };
        const task = await Task.findById(id);
        if (!task || task.user.toString() !== req.user.id) {
            return res.status(404).json({ message: 'Task not found' });
        }
        // Ensure label and attachment are arrays if provided
        if (updates.label && !Array.isArray(updates.label)) {
            updates.label = [updates.label];
        }
        if (updates.attachment && !Array.isArray(updates.attachment)) {
            updates.attachment = [updates.attachment];
        }
        Object.assign(task, updates);
        await task.save();
        await sendForEmbedding(task._id, task.title, task.description);
        res.status(200).json(task);
    } catch (error) {
        console.error('Error updating task:', error);
        res.status(500).json({ message: 'Server error', error: error.message });
    }
});

// DELETE a task by ID
app.delete('/tasks/:id', async (req, res) => {
    try {
        const task = await Task.findById(req.params.id);
        if (!task || task.user.toString() !== req.user.id) {
            return res.status(404).json({ message: 'Task not found' });
        }
        await task.deleteOne();
        res.status(200).json({ message: 'Task deleted successfully' });
    } catch (error) {
        console.error('Error deleting task:', error);
        res.status(500).json({ message: 'Server error', error: error.message });
    }
});

// DELETE all scheduled (non-archived) tasks for the logged-in user
app.delete('/tasks', async (req, res) => {
    try {
        await Task.deleteMany({ user: req.user.id, completed: false });
        res.status(200).json({ message: 'All scheduled tasks deleted successfully' });
    } catch (error) {
        console.error('Error deleting all scheduled tasks:', error);
        res.status(500).json({ message: 'Server error', error: error.message });
    }
});

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, path.join(__dirname, 'uploads'));
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + '-' + file.originalname);
  }
});
const upload = multer({ storage: storage });

// File upload endpoint
app.post('/upload', upload.array('files', 10), (req, res) => {
  const files = req.files.map(file => `/uploads/${file.filename}`);
  res.status(200).json({ files });
});

// Serve uploaded files statically
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// --- Start the server ---
app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
